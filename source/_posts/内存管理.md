---
title: 避免几种常见的内存泄漏
date: 2018-05-13 23:31:35
tags:
- web前端
- JS
- 内存管理

categories:
- IT
---


有一个比喻说明内存,CPU,硬盘的关系:
你是cpu的话，内存就是碗，硬盘就是锅。你吃饭时直接用碗，但是东西是从锅里盛出来的;这很好的说明了内存的作用。

<!-- more -->

内存是连接CPU 和其他设备的通道，起到缓冲和数据交换作用。 当CPU在工作时，需要从硬盘等外部存储器上读取数据，但由于硬盘这个“仓库”太大，加上离CPU也很“远”，运输“原料”数据的速度就比较慢，导致CPU的生产效率大打折扣！为了解决这个问题，人们便在CPU与外部存储器之间，建了一个“小仓库”—内存。
所以内存是寸土寸金,使用完了必须及时释放,给后来者腾地方.


##  内存生命周期

不管你在使用什么编程语言，内存的生命周期基本上都是一样的：

1. 分配内存 - 操作系统为你的程序分配内存并且允许其使用。在低层次语言中（比如C），这正是开发者应该处理的操作。在高层次的语言，就由语言帮你实现了。

2. 使用内存 - 当你的程序确实在使用之前分配的内存的阶段。当你在使用你代码里面分配的变量的时候会发生读以及写操作。

3. 释放内存 - 这个阶段就是释放你不再需要的内存，从而这些内存被释放并且能够再次被使用。和分配内存操作一样，这在低层次的语言也是开发者需要明确的操作。
  
  
##  JS中内存的分配
  
  JavaScript 将开发者从内存分配的处理中解放出来——JavaScript自身可以利用声明变量来完成这些任务。

```
    var n = 374; // 为一个数字分配内存
    var s = 'sessionstack'; 
	
    var o = {
      a: 1,
      b: null
    }; 
    
    var a = [1, null, 'str'];  
    
    function f(a) {
      return a + 3;
    } 
    
    someElement.addEventListener('click', function() {
      someElement.style.backgroundColor = 'blue';
    }, false);

```

##  JS中使用内存

基本上在JavaScript中分配内存，就意味着在其中读写。

这可以通过对一个变量或者一个对象的属性甚至是向函数传递一个参数来完成。


## JS中释放内存

大多数的内存管理的问题就来自于这个阶段。

最困难的任务就是如何知道何时被分配的不再需要了。它经常需要开发者决定在程序的什么地方某段内存不再需要了并且对其进行释放。

高层次语言内嵌了一个称为垃圾收集器的软件，他的任务就是跟踪内存分配并且用于需找不再需要的分配过的内存，并且自动地对其进行释放。


## 垃圾收集器

### 1. 基于引用计数的垃圾收集

引用计数是一种垃圾回收的形式，每一个对象都会有一个计数来记录有多少指向它的引用。其引用计数会变换如下面的场景

当对象增加一个引用，比如赋值给变量，属性或者传入一个方法，引用计数执行加1运算。
当对象减少一个引用，比如变量离开作用域，属性被赋值为另一个对象引用，属性所在的对象被回收或者之前传入参数的方法返回，引用计数执行减1操作。
当引用计数变为0，代表该对象不被引用，可以标记成垃圾进行回收。

循环产生的问题:

```
function f() {
  var o1 = {};
  var o2 = {};
  o1.p = o2; // o1 references o2
  o2.p = o1; // o2 references o1. This creates a cycle.
}

f();
```

上面实例之中，创建两个对象，并且互相引用，因此就会产生一个循环。当函数调用结束之后它们会走出作用域之外，因此它们就没什么用并且可以被释放。但是，基于引用计数的算法认为这两个对象都会被至少引用一次，所以它俩都不会被垃圾收集器收集。

实际上单纯的基于引用计数实现的计数器无法处理循环引用带来的问题。

### 2. 标记-清除算法

为了决定哪个对象是需要的，算法会决定是否这个对象是可访问的。

这个算法由以下步骤组成：

1. 这个垃圾收集器构建一个“roots”列表。Root是全局变量，被代码中的引用所保存。在 JavaScript中，“window”就是这样的作为root的全局变量的例子。

2. 所有的root都会被监测并且被标志成活跃的（比如不是垃圾）。所有的子代也会递归地被监测。所有能够由root访问的一切都不会被认为是垃圾。

3. 所有不再被标志成活跃的内存块都被认为是垃圾。这个收集器现在就可以释放这些内存并将它们返还给操作系统。

![2503350814-56f154684b8fc_articlex.png](https://i.loli.net/2018/05/31/5b0f575f490c9.png)

2012年，所有的现代浏览器都使用标记-清除垃圾收集器。过去几年，JavaScript垃圾收集（代数/增量/并行/并行垃圾收集）领域的所有改进都是对该算法（标记和扫描）的实现进行了改进，但并没有对垃圾收集算法本身的改进， 其目标是确定一个对象是否可达。

在上述的第一个例子中，在函数调用返回之后，这两个对象不能够被全局对象所访问。因此，垃圾收集器就会发现它们不能够被访问了。


## 什么是内存泄露？
实质上，内存泄漏可以被定义为应用程序不再需要的内存，但是由于某些原因不会返回到操作系统或可用内存池。

编程语言有支持管理内存的不同方法。 然而，某块内存是否被使用实际上是一个不可判定的问题。 换句话说，只有开发人员可以清楚一个内存是否可以返回到操作系统。

常见的内存泄漏

### 1. 全局变量

JavaScript 使用一种有趣的方式处理未声明的变量：一个未声明变量的引用会在全局对象内部产生一个新的变量。在浏览器的情况，这个全局变量就会是window。换句话说：

```
function foo(arg) {
    bar = "some text";
}
```

等同于

```
function foo(arg) {
   window.bar = "some text";
}
```

这个例子中，泄露就仅仅是一个字符串并不会带来太多危害，但是它可能会变得更糟。

另外一种可能产生意外的全局变量的方式是：
```
function foo() {
    this.var1 = "全局";
}

foo()

```
为了阻止这些错误的发生，可以在js文件头部添加'use strict'。这将会使用严格模式来解析 JavaScript ;从而阻止意外的全局变量。

如果你必须使用全局变量来存储大量数据，请确保在完成之后将其分配为null或重新分配。

### 2. 被遗忘的计时器和回调

```
var serverData = loadData();
setInterval(function() {
    var renderer = document.getElementById('renderer');
    if(renderer) {
        renderer.innerHTML = JSON.stringify(serverData);
    }
}, 5000);

```

这个例子说明了计时器可能发生的情况：计时器可能会产生再也不被需要的节点或者数据的引用。

renderer所代表的对象在未来可能被移除，让部分interval 处理器中代码变得不再被需要。然而，这个处理器不能够被收集因为interval依然活跃的（这个interval需要被停止从而表面这种情况）。如果这个interval处理器不能够被收集，那么它的依赖也不能够被收集。这意味这存储大量数据的severData也不能够被收集。

在这种观察者的情况下，做出准确的调用从而在不需要它们的时候立即将其移除是非常重要的。

类似的还有时间监听器,确定不再使用,要将其移除
```
element.addEventListener('click', onClick);

// Do sth

element.removeEventListener('click', onClick);
```

###  3. DOM 之外的引用
有时将DOM节点存储在数据结构中可能是有用的。 假设要快速更新表中的几行内容。 存储对字典或数组中每个DOM行的引用可能是有意义的。 当发生这种情况时，会保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。 如果将来某个时候您决定删除这些行，则需要使两个引用置为不可访问。

```
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image')
};

function doStuff() {
    image.src = 'http://example.com/image_name.png';
}

function removeImage() {
    document.body.removeChild(document.getElementById('image'));
}

```

虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用，换言之, DOM元素还在内存里面
