---
title: 多进程的浏览器
date: 2018-06-03 22:49:02
tags:
- 浏览器
- web前端
- JS
categories:
- IT
---


现在的页面越来越复杂,H5, Webapp,或者Hybrid App等等，它们执行的任务越来越重，不再像以前都是文档类型的页面，现在的页面更像是一个应用。它们对系统资源的需求变大，同时不稳定的机率也增大。如果同时开启多个页面，就会引入更长的操作延迟，严重影响用户体验。它页面浏览中核心的功能是页面的渲染(从DOM Tree到Render Tree)，JS的执行, 它是一个需要集中运算的功能，相对独立于系统资源的使用。而系统资源的使用又可以集中起来共享使用，也有利于将不安全的页面与系统资源隔离开来（沙箱机制的需求）。
  
 <!-- more -->
### 为什么要多进程?主要有这么几个原因
1. 避免单个page crash影响整个浏览器
2. 避免第三方插件crash影响整个浏览器
3. 多进程充分利用多核优势
4. 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

当然缺点也很明显:占用大量的内存和cpu资源



### 现代浏览器主要有哪些进程

1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有
   -  负责浏览器界面显示，与用户交互。如前进，后退等
   -  负责各个页面的管理，创建和销毁其他进程
   -  负责绘制用户界面
   -  负责网络资源的管理下载等
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU进程：最多只有一个，用于3D绘制等
4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程（有时候会优化，如多个空白tab会合并成一个进程），互不影响。
  
以下主要介绍浏览器渲染进程中常驻线程

###   GUI 线程

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
###   JS 引擎线程
- JS引擎线程负责解析Javascript脚本
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序

注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了,因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

#### JS的运行机制

- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

![js事件队列](https://i.loli.net/2018/08/26/5b8214b3a8e92.png)

###   事件触发线程

- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
- 
注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。


###   定时器线程

- setInterval与setTimeout所在线程
- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）

注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

``` js
setTimeout(function(){
    console.log('hello world!');
}, 0);

console.log('begin');
```

所以以上代码输出顺序为先begin,再hello world. 

###  网络请求线程

- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

